# 3.4 迭代器介绍

类似于指针类型，**迭代器**（iterator）也提供了对对象的间接访问，其中“对象”指的是容器中的元素或string对象中的字符。所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。

迭代器有**有效和无效**之分：

- 有效：指向某个元素或指向容器中尾元素的下一位置
- 无效：有效以外的其他情况都属于无效

*可以复习一下2.3.2中指针的4种状态



### 3.4.1 使用迭代器

#### 迭代器类型

拥有迭代器的标准库类型使用**iterator和const_iterator**来表示迭代器的类型。

```cpp
string::iterator it;			 //it能读写string对象中的字符
vector<int>::const_iterator it2; //it2只能读元素，不能写元素
```

如果迭代器的对象是常量，那么只能使用const_iterator；如果不是常量，则二者都可以使用。



#### 迭代器运算符

- **判断两个合法的迭代器是否相等**（== 或 !=）：

  如果两个迭代器指向的元素相同或都是同一个容器的尾后迭代器，则它们相等，反之则不相等。

- **移动迭代器**：

  迭代器使用**递增运算符**（++）来从一个元素移动到下一个元素。

  ps：因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。

- ##### begin和end运算符

  有迭代器的类型同时拥有返回迭代器的成员，比如begin和end成员。

  - **begin成员**：返回指向第一个元素（或第一个字符）的迭代器
  - **end成员**：返回指向容器（或string对象）尾元素的下一个位置（one past the end）的迭代器，常被称为**尾后迭代器**（off-the-end literator）

  如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。可以用这个性质**检验容器是否为空**。

  两者返回的具体类型由**对象是否是常量**决定，如果对象是常量，begin和end返回const_iterator；如果不是常量，返回iterator。

  为了便于专门得到const_iterator类型的返回值，C++11新标准引入了**cbegin和cend**。不论vector对象（或string对象）本身是否是常量，返回值都是const_iterator。



#### 结合解引用和成员访问操作

**解引用**迭代器可以获得迭代器所指的对象，如果该对象的类型恰好是类，则有可能希望进一步访问它的成员。

```cpp
(*it).empty()	//解引用it，然后调用结果对象的empty成员。// 注意前面的括号不能漏
```

上一个表达式还可以进一步简化：使用**箭头运算符**（->）

```cpp
//箭头运算符把解引用和成员访问两个操作结合在一起。上面的表达式等价于：
it->empty()
```



#### 使迭代器失效的操作

注意：但凡是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。

9.3.6节会进一步解释原因





### 3.4.2 迭代器运算（iterator arithmetic）

string和vector的迭代器支持更多的运算，包括使迭代器**每次移动跨过多个元素**和**关系运算**。

详见表3.7



#### 迭代器的算术运算

- 令迭代器**和一个整数值相加（或相减）**，其返回值是向前（或向后）移动了若干个位置的迭代器。
- **两个迭代器相减**：结果是两个迭代器的距离，类型是名为**difference_type**的**带符号**整型数。

- 使用**关系运算符**（<、<=、>、>=）进行比较，指向的容器位置在更后的迭代器更大。

  重要前提：参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置



#### 使用迭代器实现二分搜索

此处建议认真看书并自己举个例子推理一下全过程试试。