# 数组

**数组**是一种类似于标准库类型vector的数据结构，但是在性能和灵活性的权衡上又与vector有所不同。

- **相似点**：数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问

- **不同点**：数组的**大小固定**，不能随意向数组中增加元素。这个特点对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。

  如果不清楚元素的确切个数时，使用vector更好。



### 3.5.1 定义和初始化内置函数

#### 数组的定义

数组是一种**复合类型**。数组的声明形如**a[d]**，其中a是数组的**名字**，d是数组的**维度**。

维度说明了数组中元素的个数，因此必须大于0，且必须是一个常量表达式。

定义时**必须指定数组的类型**，不允许使用auto关键字。且数组的元素应为对象，因此也**不存在引用的数组**。

```cpp
//例：
int arr[10];	//含有10个整数的数组

constexpr unsigned sz = 42;	//常量表达式
int *parr[sz];	//含有42个整型指针的数组
```



#### 数组的初始化

默认情况下，数组的元素被**默认初始化**。

使用**列表初始化**时，允许忽略数组的维度，此时又有以下几种情况：

- 如果在声明时未指定维度，编译器会根据初始值的数量计算并推测出来；

- 如果指明了维度，那么初始值的总数量不应超出指定的大小；

- 如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化为默认值。

```cpp
//例：
int iarr[] = {0, 1 ,2};	//含有三个元素的数组，元素值分别是0,1,2
```

**特别注意**：

- **字符数组**可以用字符串字面值进行初始化，此时注意考虑字符串结尾的**空字符**`'\0'`

- 数组内容**不允许拷贝和赋值**



### 3.5.2 访问数组元素

与标准库类型vector和string一样，数组的元素也能使用范围for语句或下标运算符来访问。

在使用数组下标时，要注意检查下标是否越界。数组下标通常定义为**size_t**类型，这是一种机器相关的**无符号**类型。

在需要遍历数组的所有元素时，最好的方法也是使用**范围for语句**，可以减轻人为控制遍历过程的负担。



### 3.5.3 指针和数组

C++语言中，指针和数组有非常紧密的联系。使用数组时，编译器一般会把它转换成指针。在一些情况下，数组的操作实际上是指针的操作。



有几个重要的特性：

- 通常情况下，使用**取地址符**来获取指向某个对象（可以是任意对象）的指针。因此，对数组的元素使用取地址符就可以得到指向该元素的指针。

- 在很多时候，编译器都会自动将数组名字替换为一个**指向数组首元素的指针**。

  ```cpp
  string nums[] = {"one","two","three"};
  string *p = nums;	//等价于p = &nums[0]
  ```

- 当数组作为一个**auto**变量的初始值时，推断得到的类型是**指针**。

  不过当使用decltype时，上述转换不会发生。

- 可以**用指针遍历数组中的元素**。前提：先获取到指向数组第一个元素的指针和指向数组尾后的指针。

  - 更简单安全的方法：使用**begin**和**end**函数。例：

    ```cpp
    int *pbeg = begin(arr), *pend = end(arr);
    ```

  PS：尾后指针不能执行解引用和递增操作。

- 指针运算和之前所学的迭代器运算的使用意义完全一致。几个注意点：

  - 两指针相减的结果的类型是一种名为**ptrdiff_t**的标准库类型，是一种带符号类型
  - 同时使用加法运算和解引用时，注意圆括号的使用。
  - 对数组执行下标运算其实是对指向数组元素的指针执行下标运算。且数组是内置类型，所用的索引值是sign类型，内置的下标运算可以处理**负值**，这一点与vector和string不同。





### 3.5.4 C风格字符串

字符串字面值是一种通用结构的实例，这种结构即是C++由C继承而来的**C风格字符串**（C-style character string）。按此习惯书写的字符串存放在字符数组中并以**空字符结束**（null terminated）。

C风格字符串的函数定义在**cstring**头文件中。传入此类函数的指针必须指向**以空字符作为结束**的数组。常用函数有：strlen、strcmp、strcat、strcpy。

```cpp
//例：
char ca[] = {'C','+','+'};
cout << strlen(ca) << endl;//错误：ca没有以空字符作为结束
```

使用时注意与**标准库string**进行区分，一般来说使用标准库string比使用C风格字符串更安全更高效。



### 3.5.5 与旧代码的接口

为了与使用了数组或C风格字符串的代码衔接，C++专门提供了一组功能：

#### 混用string对象和C风格字符串

任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代。

- 允许使用以空字符结束的字符数组来**初始化**string对象或为string对象**赋值**
- 在string对象的**加法运算**中，允许使用以空字符结束的字符数组作为**其中一个**运算对象。（但不能两个运算对象都是）
- 在string对象的**复合赋值运算**中，允许使用以空字符结束的字符数组作为**右侧**的运算对象。

但上述性质反过来是不成立的。

为了完成此功能，string提供了一个名为**c_str**的成员函数，返回值是一个C风格的字符串，即返回值是一个指针，该指针指向一个以空字符结束的字符数组。

```cpp
//例：
string s("hello");
const char *str = s.c_str();
```

#### 使用数组初始化vector对象

虽然不允许使用vector对象初始化数组，但允许使用数组来初始化vector对象。

初始化时，需要指明拷贝区域的**首元素地址**和**尾后地址**。

```cpp
//例：
int int_arr[] = {0,1,2,3,4,5};
vector<int> subVec(int_arr + 1, int_arr + 4);
```



应尽量使用标准库类型**vector和迭代器**，避免使用内置数组和指针；尽量使用**string**，避免使用C风格的基于数组的字符串。