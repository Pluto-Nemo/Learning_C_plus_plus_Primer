# 4.11类型转换

C++中，某些类型之间有关联。如果两种对象可以**相互转换**（conversion），那么它们就是关联的。

程序自动执行，无需程序员介入的类型转换，称为**隐式转换**（implicit conversion）。

**发生隐式类型转换的情况**：

- 在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。
- 在条件中，非布尔值转换成布尔类型。
- 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型。
- 如果算术运算或关系运算对象有多种类型，需要转换成同一种类型。
- 函数调用时也会发生类型转换。（详见第六章）





### 4.11.1 算术转换

**算术转换**（arithmetic conversion）的含义是把一种算术类型转换成另外一种算术类型。

算术转换的规则定义了一套类型转换的层次，被设计得尽可能避免损失精度，其中运算符的运算对象将转换成**最宽**的类型。如表达式中既有整型又有浮点型时，整型会转换成浮点型。



#### 整型提升

**整型提升**（integral promotion）：负责把小整数类型转换成与之最接近的较大的整数类型。

- 对于bool、char、signed char、unsigned char、short和unsigned short等类型来说，只要它们所有可能的值都能存在int里，它们就会提升成int；否则，提升成unsigned int。

  ```cpp
  //例：
  short sval;	 char cval;
  sval + cval；  //sval和cval都提升成int
  ```

- 较大的char类型（wchar_t、char16_t、char32_t）提升成int、unsigned int、long、unsigned long、long long和unsigned long long中最小的一种类型。（前提：转换后的类型要能容纳原类型所有可能的值。）



#### 无符号类型的运算对象

如果运算对象的类型是**无符号类型**，那么转换的结果就要依赖于**机器中各个整数类型的相对大小**。

**转换过程**：首先执行整型提升。如果结果的类型匹配，则无须进行进一步的转换。如果不匹配，则进行后续转换：

<table>
	<tr>
	    <th colspan="2">（提升后的）运算对象</th>
	    <th>进行的转换</th>
	</tr>
    <tr>
	    <td colspan="2">两个类型都是带（/无）符号的</td>
	    <td>小类型转换成较大类型</td>
	</tr>
	<tr>
	    <td rowspan="2">一个是无符号类型，另一个是带符号类型</td>
	    <td>无符号类型 ≥ 带符号类型</td>
	    <td>带符号类型转换成无符号类型<br/>（当带符号类型是负值时，转换有风险，详见p32）</td>
	</tr>
	<tr>
	    <td>带符号类型＞无符号类型</td>
        <td>转换结果依赖于机器：<br/>若无符号类型的所有值都能存在带符号类型中，则无符号类型转换成带符号类型；反之，带符号类型转换成无符号类型</td>
	</tr>
</table>

```cpp
//例：
int ival;  double dval;
ival + dval;   //ival转换成dval。（对应表格第一种情况）

unsigned long ulval;
ival + ulval;  //ival转换成unsigned long。（对应表格第二种情况）

unsigned int uival;  long lval;
uival + lval;  //根据unsigned int和long所占空间的大小进行转换。（对应表格第三种情况）
```





### 4.11.2 其他隐式类型转换

除了算术转换之外还有几种隐式类型转换：

- **数组转换成指针**：在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。

  当数组被用作decltype关键字的参数，或者作为取地址符（&）、sizeof及typeid（19.2.2节介绍）等运算符的运算对象时，上述转换不会发生。

- **指针的转换**：

  - 常量整数值0或字面值nullptr可以转换成任意指针类型
  - 指向任意非常量的指针能转换成void*
  - 指向任意对象的指针能转换成const void*
  - 15.2.2节介绍，在有继承关系的类型间还有另一种指针转换方式

- **转换成布尔类型**：如果指针或算术类型的值为0，转换结果是false；否则转换结果是true。

- **转换成常量**：如果T是一种类型，则可以将指向T 的指针或引用分别转换成指向const T的指针或引用。（参见2.4.1节p54和2.4.2p56）

  但相反的转换不存在，因为它试图删除掉底层const。

- **类类型定义的转换**：类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换。（7.5.4节p263有拒绝同时多种类类型转换请求的例子）

  之前使用过的类类型转换的例子：

  - 在需要string类型的地方使用C风格字符串（参见3.5.5p111）
  - 在条件部分读入istream





### 4.11.3 显式转换

显式地转换，又称作**强制类型转换**（cast）。这种方法本质上是非常危险的。

#### 命名的强制类型转换

一个命名的强制类型转换具有如下形式：

```cpp
cast-name<type>(expression);
//type是转换的目标类型；expression是要转换的值
//cast-name指定了执行的是哪种变换，是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种
```

如果type是引用类型，则结果是左值。



#### static_cast

任何具有明确定义的类型转换，只要**不包含底层const**，都可以使用static_cast。

```cpp
//例：将int型运算对象强制转换成double，使表达式执行浮点数除法。
double slope = static_cast<double>(j) / i;
```

**重要的使用情景**：

- 当需要把一个较大的算数类型赋值给较小的算术类型时，使用static_cast可以使关于精度损失的警告信息关闭。

- 应用于编译器无法自动执行的类型转换。

  如：使用static_cast找回存在于void*指针中的值。这个过程中必须确保转换后所得的类型与指针所指的类型相同，如果不同，将产生未定义的后果。

  ```cpp
  //例：
  void* p = &dval;
  double *dp = static_cast<double*>(p);//将void*转换回初始的指针类型
  ```



#### const_cast

const_cast：只能改变运算对象的**底层const**（参见2.4.3节p57）。

**只有它**能够改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性将引发编译器错误。同样，也不能用const_cast改变表达式的类型。

```cpp
//例：
const char *pc;
char *p = const_cast<char*>(pc);  //正确，但是通过p写值是未定义的行为。
```

一旦我们**去掉**了某个对象的**const性质**，就可以对该对象进行写操作了。如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为；反之，则会产生未定义的后果。

const_cast常用于有**函数重载**的上下文中，具体见6.4节p208。



#### reinterpret_cast

reinterpret_cast通常为运算对象的**位模式**提供**较低层次**上的重新解释。

```cpp
//例：
int *ip;
char *pc = reinterpret_cast<char*>(ip);
//此时必须牢记pc所指的真实对象是一个int而非char，如果把pc当成普通的字符指针使用则可能在运行时出错。
```

使用reinterpret_cast是非常危险的，其关键问题在于：**类型改变了，但编译器没有给出任何警告或错误的提示信息。**要想安全地使用reinterpret_cast必须对涉及的类型和编译器实现转换的过程都非常了解。



#### dynamic_cast

dynamic_cast支持运行时类型识别。

将在19.2节p730详细介绍



#### 建议：避免强制类型转换（在有**函数重载**的上下文中const_cast时除外）

因为强制类型转换干扰了正常的类型检查。

每次书写了一条强制类型转换语句，都应该反复斟酌能否以其他方式实现相同的目标。就算实在无法避免，也应该尽量限制类型转换值的作用域，并记录对相关类型的所有假定，以减少错误发生的机会。

#### 

#### 旧式的强制类型转换

早期版本的C++中，显式地强制类型转换包含两种形式：

```cpp
type(expr);  //函数形式的强制类型转换
(type)expr;  //C语言风格的强制类型转换
```

根据所涉及的类型不同，旧式的强制类型转换分别具有与const_cast、static_cast或reinterpret_cast相似的行为。

ps：与命名的强制类型转换相比，旧式的从表现形式上来说不那么清晰明了，不建议使用，因此就不作详述了。