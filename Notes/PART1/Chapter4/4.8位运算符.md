# 4.8 位运算符

**位运算符**作用于**整数**类型的运算对象，并把运算对象看成是**二进制位的集合**。位运算符提供检查和设置二进制位的功能。

位运算符表格见p136表4.3，都满足**左结合律**。

**关于位运算符的运算对象**:

- 如果运算对象是“小整型”，则它的值会被**自动提升**成较大的整数类型。（参见4.11.1 p142）

- 运算对象既可以是带符号的，也可以是无符号的。

  - 如果运算对象是带符号的且值为负，那么位运算符如何处理“符号位”依赖于机器。
  - 此时的左移操作可能会改变符号位的值，因此是一种**未定义**的行为。
  - 所以强烈建议仅将位运算符用于处理**无符号类型**。

  

#### 移位运算符（又叫IO运算符）

**左移运算符`<<`**和**右移运算符`>>`**的内置含义是：对其运算对象执行基于二进制位的移动操作。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。移出边界之外的位会被舍弃掉。

注意：

- 右侧运算对象一定**不能为负**，而且值必须严格小于结果的位数，否则就会产生未定义的行为。

- 左移运算符将在右侧插入**值为0**的二进制位。
- 右侧运算符的行为依赖于**左侧运算对象的类型**：
  - 如果该运算对象是unsigned，则在左侧插入值为0的二进制位。
  - 如果是signed，则在左侧插入符号位的副本或值为0的二进制位，实际视具体环境而定。



当我们使用移位运算符的重载版本进行IO 操作时，重载运算符的优先级和结合律都与它的内置版本一样。下面将具体说明：

- 移位运算符满足**左结合律**。

  在[1.2初识输入输出](../../PART0/Chapter1/1.2初识输入输出.md)中我们提到：

> ```cpp
> std::cout << "Hello World" << std::endl;
> //等价于
> (std::cout << "Hello World") << std::endl;
> //也等价于
> std::cout << "Hello World";
> std::cout << std::endl;
> ```
>
> 输入同理

​		其等价的原因就是因为移位运算符满足左结合律，此处做了两次输出/输入。

- 移位运算符**优先级介于中间**：

  比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。所以需要注意括号的添加。

  ```cpp
  //例：
  cout << (10 < 42);	//输出1
  ```



#### 位求反运算符

**位求反运算符（`）**：将运算对象逐位求反后生成一个新值。

此处书中的例子涉及一个char的类型提升，这部分内容在4.11节有详细说明。



#### 位与、位或、位异或运算符

**与`&`、或`|`、异或`^`**运算符：在两个运算对象上逐位执行相应的逻辑操作。

- 位与运算符：两个运算对象的对应位置**都是**1，则运算结果中该位为1，否则为0。
- 位或运算符：两个运算对象的对应位置**至少有一个**为1，则运算结果中该位为1，否则为0。
- 位异或运算符：两个运算对象的对应位置**有且只有一个**为1，则运算结果中该位为1，否则为0。

注意区分 位运算符 和 逻辑运算符。



#### 使用位运算符

此处就摘取了代码用于回顾，具体过程还是看书吧。

```cpp
unsigned long quiz1 = 0;			//位的集合
quiz1 |= 1UL << 27;					//表示学生27通过了测验
quiz1 &= `(1UL << 27);				//学生27没有通过测验，进行修改
bool status = quiz1 & (1UL << 27);  //检查学生27是否通过了测验
```

