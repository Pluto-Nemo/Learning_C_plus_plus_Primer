# 6.1 函数基础

一个典型的**函数**（function）定义包括：

- 返回类型（return type）
- 函数名字
- 由0个或多个形参（parameter）组成的列表
- 函数体（function body）

执行函数：使用**调用运算符**（call operator）`()`。

它作用于一个表达式，该表达式是函数或者指向函数的指针。括号内是一个用逗号隔开的实参（argument）列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。

```cpp
int fact(int val)	  //函数名为fact，它作用于一个整型参数
{
    int ret = 1;
    while (val > 1)
        ret *= val--;
    return ret;		 //返回一个整型值
}
```



**函数的调用过程：**

1. 用实参初始化函数对应的形参。

2. 将控制权转移给被调用函数。

   此时，主调函数（calling function）的执行被暂时中断，被调函数（called function）开始执行。

**return语句完成的工作**：

1. 返回return语句中的值（如果有的话）。
2. 将控制权从被调函数转移回主调函数。函数的返回值用于初始化调用表达式的结果。
3. 继续完成调用所在的表达式的剩余部分。



#### 函数的形参列表

形参列表中的形参通常用**逗号**隔开，其中每个形参都是含有一个声明符的声明。任意两个形参**不能同名**，且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。

形参名是可选的，但由于我们无法使用未命名的形参，所以形参一般都应该有个名字。但是否设置未命名的形参不影响调用时提供的实参数量。即使某个形参不被函数使用，也必须为它提供实参

函数的形参列表**可以为空，但是不能省略**。**定义一个不带形参的函数的方法**:

1. 书写一个空的形参列表（最常用）

```cpp
void f1(){ /*...*/ }    //隐式地定义空形参列表
```

2. 使用关键字void表示函数没有形参（与c语言兼容）

```cpp
void f2(void){ /*...*/ } //显式地定义空形参列表
```



#### 形参和实参

**实参是形参的初始值**。实参与形参存在对应关系，但是并没有规定实参的求值顺序，编译器可以任意可行的顺序对实参求值。

实参的**类型和数量**都要与形参匹配：

- 数量：必须一致

- 类型：实参的类型必须是能转换成形参类型的

  ```cpp
  //以前文fact函数为例
  fact(3.14)； //正确，double型的实参可以转换成int类型
  ```

  

#### 函数返回类型

函数的返回类型不能是**数组**或**函数**类型，但可以是**指向数组或函数的指针**。（将在6.3.3和6.7节中介绍）

一种特殊的返回类型是**void**，表示函数**不返回任何值**。



### 6.1.1 局部对象

C++中，名字有**作用域**，对象有**生命周期**（lifetime）。

- 名字的作用域：是程序文本的一部分，名字在其中可见
- 对象的生命周期：程序执行过程中该对象存在的一段时间

形参和函数体内部的变量统称为**局部变量**（local variable），局部变量的生命周期依赖于定义的方式。

在**所有函数体之外**定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁、



#### 自动对象

我们把只存在于**块执行期间**的对象称为**自动对象**（automatic object）。当块的执行结束后，块中创建的自动对象将被销毁，它的值就变成未定义的了。

**自动对象的初始化**：

- 形参对应的自动对象：使用传递给函数的实参来初始化。函数开始时为形参申请存储空间，函数结束时形参销毁。

- 局部变量对应的自动对象：如果变量定义本身含有初始值，就用这个初始值进行初始化；否则执行默认初始化。

  这意味着内置类型的未初始化局部变量将产生未定义的值。



#### 局部静态对象

有时我们需要让局部变量的生命周期贯穿函数调用及之后的时间，可以将局部变量定义成**static**类型，得到**局部静态变量**（local static object）。局部静态变量在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。在此期间，即使对象所在的函数结束执行也不会对它有影响。

```cpp
//例：
size_t count_calls()
{
    static size_t ctr = 0;  //调用结束后，这个值仍然有效
    return ++ctr;
}
```

如果局部静态变量没有显式的初始化，它将执行值初始化（见3.3.1节p88）内置类型的局部静态变量初始化为0。





### 6.1.2 函数声明

函数声明也称为**函数原型**（function prototype）。和其他名字一样，函数的名字也必须**在使用之前声明**。函数只能定义一次，但可以声明多次。（唯一例外将在15.3节介绍）

函数声明和定义非常类似，唯一的区别是**函数声明无需函数体**，用一个分号替代即可。声明中形参的名字也可以省略，但写上可以增加代码的可读性。

函数的**三要素**描述了函数的接口，说明了调用该函数所需的全部信息：

- 返回类型
- 函数名
- 形参类型

**编程建议：**

- 函数在头文件中声明，在源文件中定义
- 定义函数的源文件应该包含含有函数声明的头文件，编译器会验证函数的定义和声明是否匹配





### 6.1.3 分离式编译

C++语言支持**分离式编译**（separate compilation），即允许编写程序时按照逻辑关系把程序分割到几个文件中去，每个文件独立编译。

我们有Chapter6.h文件和fact.cc文件分别包含fact函数的声明和定义。还有factMain.cc文件，其中包含了main函数，main函数将调用fact函数。如果要生成**可执行文件**（executable file），编译的过程如下：

```powershell
$ CC factMain.cc fact.cc          # generates factMain.exe or a.out
$ CC factMain.cc fact.cc -o main  # generates main or main.exe

# $：系统提示符   CC：编译器的名字，如gcc、g++   #：表示后面是命令行下的注释语句
```

之后运行可执行文件，就会执行我们定义的main函数。

如果修改了其中一个源文件，则只需重新编译改动了的文件。通过分离式编译生成后缀名是**.obj**（Windows）或**.o**（UNIX）的文件（后缀名的含义是该文件包含**对象代码**（object code）），接下来编译器负责把对象文件链接在一起形成可执行文件。编译的过程如下：

```powershell
$ CC -c factMain.cc 		    # generates factMain.o
$ CC -c fact.c fact.cc 		    # generates fact.o
$ CC factMain.o fact.o		    # generates factMain.exe or a.out(linux)
$ CC factMain.o fact.o -o main  # generates main or main.exe
```

参数说明：

- -c：只编译不链接，生成生成对象代码文件
- -o：后跟输出文件名，如果没有指定，默认文件名是a.out
- -I（大写的i）：指定额外的头文件搜索路径，如果没有指定，则只会在默认路径（即当前目录、环境变量指定的目录和默认目录）下搜索