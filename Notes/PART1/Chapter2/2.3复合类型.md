# 2.3 复合类型

**复合类型**（compound type）是指**基于其他类型**定义的类型。C++有多种复合类型，本章介绍其中两种：引用和指针。



### 2.3.1 引用

**引用**（reference）类型引用（refers to）另外一种类型。它**并非对象**，只是为被引用的对象起了另外一个名字。

**定义方式**：将声明符写成**&d**（其中d是声明的变量名）

注意：因为引用本身不是对象，所以**不能定义引用的引用**。

```cpp
//例：
int ival = 1024;
int &refVal = ival;	//refVal指向ival（是ival的另一个名字）
int &refVal2 = 10;	//错误，引用类型的初始值必须是一个对象
```



#### 引用的初始化

- 定义引用时，程序把引用和它的初始值**绑定**（bind）在一起，而不是将初始值拷贝给引用。
- 一旦初始化完成，引用将一直和初始化对象绑定，**无法再重新绑定**到另一个对象。因此引用**必须初始化**。
- 除了2.4.1节和15.2.3节的两种例外情况，其他所有引用的类型都要和绑定的对象严格匹配。
- 引用只能绑定在**变量**上，不能与字面值或某个表达式的结果绑定。



定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。



### 2.3.2 指针

**指针**（pointer）是”指向（point to）“另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的简介访问。

**定义方式**：将声明符写成***d**（其中d是变量名）

除了2.4.2节和15.2.3节的两种例外情况，其他所有指针的类型都要和绑定的对象严格匹配。



#### 获取对象的地址

使用**取地址符&**获取指针存放的对象的地址。

注意：因为引用不是对象，没有实际的地址，所以**不能定义指向引用的指针**。

```cpp
//例：
double dval;
double *p = &dval; //定义了指向double型对象的指针p，初始值是dval的地址。
```

**指针值**（即地址）应属以下4种状态之一：

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针，意味着指针没有指向任何对象
- 无效指针，也就是上述情况之外的其他值

试图访问后三种状态的指针的行为将引发错误。

建议：初始化所有指针，并尽可能等定义了对象后再定义指向它的指针。



#### 利用指针访问对象

如果指针是一个指向了某个对象的有效指针（前提），则允许使用**解引用符***来访问该对象。



#### 空指针（null pointer）

空指针不指向任何对象。在试图使用一个指针之前，代码可以首先检查它是否为空。

**生成空指针的办法**：

```cpp
int *p1 = nullptr;	//推荐使用 //等价于int *p1 = 0;
int *p2 = 0;		//直接将p2初始化为字面常量0
int *p3 = NULL；	   //需要先#include cstdlib //等价于int *p3 = 0；
```

注意：不可直接将int变量直接赋给指针，即使它的值恰好等于0也不行。

​			任何非0指针对应的条件值都是true——这个特点可用于检验指针是否为空



#### void* 指针

void*是一种特殊的指针类型，可用于存放**任意对象**的地址。

它可以做的操作比较有限，不能直接操作void*指针所指的对象。（因为对象的类型不确定）





#### 指针与引用的区别

- 指针本身就是一个对象，允许对指针赋值和拷贝。而且在指针的声明周期内它可以先后指向几个不同的对象。
- 指针无须在定义时赋初值。和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

