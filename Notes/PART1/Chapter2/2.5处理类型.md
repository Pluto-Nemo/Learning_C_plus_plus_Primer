# 2.5 处理类型

### 2.5.1 类型别名

**类型别名**（type alias）是一个名字，是某种类型的同义词。使用类型别名可以增加程序的可读性。

类型别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。

有**两种方法**定义类型别名：

1. 使用关键字**typedef**

   ```cpp
   typedef double wages;	//wages是double的同义词
   typedef wages base, *p; //base是double的同义词，p是double*的同义词
   ```

2. **别名声明**（alias declaration）：使用关键字**using**，后紧跟别名和等号

   ```cpp
   using SI = Sales_item;	//SI是Sales_item的同义词
   ```

   

### 2.5.2 auto类型说明符

C++标准引入**auto**类型说明符，它让编译器通过初始值来推算变量的类型。显然，auto定义的变量**必须有初始值**。

```cpp
auto i = 0, *p = &i;	//正确，i是整数、p是整型指针
auto sz = 0, pi = 3.14; //错误，sz和pi的类型不一致
```

使用auto也可以在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中**所有变量的初始基本数据类型必须都一样**。

#### 复合类型、常量和auto

有时编译器会适当地改变结果类型使其更符合初始化规则：

1. 当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以**引用对象**的类型作为auto的类型。

2. auto一般会**忽略顶层const，保留底层const**。

   如果希望推断出的auto类型是顶层const，则需明确指出（在auto前添加const限定符）。

3. 也可以将引用的类型设为auto，此时原来的初始化规则仍适用。

4. 在一条语句中定义多个变量时切记：**符号&和*只从属于某个声明符**，而非基本数据类型的一部分，因此初始值必须是同一类型。



### 2.5.3 decltype类型指示符

C++11新标准引入第二种类型说明符**decltype**，它的作用是**选择并返回操作数的数据类型**。在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。如：

```cpp
decltype(f()) sum = x;	//sum的类型就是函数f的返回类型
```

#### 复合类型、常量和decltype

decltype处理顶层const和引用的方式与auto有所不同。

- 如果decltype使用的表达式是一个变量，则decltype返回**该变量的类型**（包括顶层const和引用）

  特别地，引用从来都作为其所指对象的同义词出现，只有用在decltype处是一个例外。

- 如果想让结果类型是引用所指的类型，可以把引用作为表达式的一部分，如书中例子`r+0`

- 如果表达式内容是**解引用**操作，则decltype将得到**引用**类型

另外，decltype的结果类型与**表达式形式**密切相关。变量名**是否加括号**会影响得到的类型：

- 变量不加括号——得到的结果就是该变量的类型

- 变量加了一层或多层括号——编译器就会把它当做可以作为赋值语句左值的特殊表达式处理，这样的decltype就会得到引用类型

  decltype((variable))的结果永远是引用，而decltype(variable)的结果只有当variable本身是一个引用时才是引用



练2.37：赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。